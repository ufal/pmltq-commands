#!/usr/bin/env perl
# pmltq     pajas@ufal.mff.cuni.cz     2008/07/08 08:34:19

# ABSTRACT: Command line interface to PML-TQ

=head1 SYNOPSIS

  pmltq <command> [<args>]

or

  pmltq -P               for a list of configured connections
  pmltq -u               for usage
  pmltq -h <commandlist> for help
  pmltq --man            for the manual page
  pmltq --version        for version

  Available pmltq commands
    convert
    delete
    help
    initdb
    load
    man
    query
    verify
    version


=head1 DESCRIPTION

B<pmltq> is a command-line interface to PML-TQ. It can use either a
SQL-based query engine, btred, ntred, or jtred (btred over a SGE
cluster) to evaluate the query. The results are printed to the
standard output.

=head1 OPTIONS

=over 5

=item B<--print-servers|-P>

Print list of configured query server connections and exit. If a HTTP
service is specified using the --server option, the service is
contacted to provide a list of all other public PML-TQ services
running on the same server for which the user is authorized.

=item B<--usage|-u>

Print a brief help message on usage and exits.

=item B<--help|-h <commandlist>>

Prints the help page and exits.

=item B<--man>

Displays the help as manual page.

=item B<--version>

Print program version.

=back

=head1 COMMANDS

=head2 convert

  pmltq convert <treebank_config> <sql_dir>

Convert from PML to SQL

=head2 delete

  pmltq delete <treebank_config>

Delete the treebank from database.

=head2 help

=head2 initdb

  pmltq initdb <treebank_config>

Initialize empty database.

=head2 load

  pmltq load <treebank_config> <sql_dir>

Load treebank to database

=head2 man

=head2 query

  pmltq query [--server <URL_or_server_ID> ] [ <options> ] [ --stdin | --query-file <filename> | --query <query> | <query> ]
  pmltq query --btred [ <options> ] [ --stdin | --query-file <filename> | --query <query> ] [ -l <filelist> |  <file(s)> ]
  pmltq query --ntred [ <options> ] [ --stdin | --query-file <filename> | --query <query> ] [ -l <filelist> |  <file(s)> ]
  pmltq query --jtred [ <options> ] [ --stdin | --query-file <filename> | --query <query> ] [ -l <filelist> |  <file(s)> ]

or

  pmltq [options] [ --print-servers|-P | --node-types | --relations ]

=head3 options

=over 5

=item B<--sql|-S>

Use SQL-based query engine (default).

=item B<--btred|-B>

Query given files or filelist using btred.

=item B<--ntred|-N>

Query given files or filelist using ntred (ntred servers
must be already up and running).

=item B<--jtred|-J>

Run query query over given files/filelist using jtred (multiple btred
instances distributed over an SGE cluster).

=item B<--server|-s> URL_or_ID

If used with SQL-based engine, this option can be used to specify a
URL (http://hostname:port) to a pmltq http server, or an ID of a
pre-configured SQL or HTTP server (use B<--print-servers> to get a
list).

If used with btred or jtred, it can be used to specify a server to run
btred/jtred on using SSH.

If used with ntred, it can be used to specify a hostname and port
(hostname:port) for the ntred hub.

=item B<--stdin>

Read query from the standard input.

=item B<--query|-Q> string

Specify PML-TQ query on the command-line.

=item B<--query-file> filename

Read PML-TQ query from a given (utf-8 encoded text) file

=item B<--query-pml-file> filename

Read PML-TQ query from a given PML file

=item B<--query-id> ID

Use query with a given ID. If the input is a text file, it can contain more than one
query. In that case, each query must start with a line of the following form:

  # == query: ID ==

where ID is a unique identifier of the query. This option can be used
to select a single query from the input.

If the input is a PML file, then the ID is just the id of the query tree.

=item B<--filelist|-l> filename

This flag can be used with B<--btred>, B<--ntred>, or B<--jtred> to
spedify a file containing a list of files to search, each on a
separate line.

Note that for B<--ntred>, the files must be already loaded on the
B<ntred> servers and this flag simply allows you to specify a subcorpus.

=item B<--auth-id> URL_or_ID

Use username/password stored in the configuration for a given service
(spcified by URL or config-file ID) on the serice specified using --server.

=item B<--username> username

Username for a HTTP or SQL PML-TQ service.

=item B<--password> password

Password for a HTTP or SQL PML-TQ service.

=item B<--limit|-L> number

Only applicable to SQL-based engine.
Specify maximum number of results (i.e. rows printed by pmltq).

=item B<--timeout|-t> seconds

Only applicable to SQL-based engine.
Specify a timeout for the query. If the query evaluation takes longer
than a given number of B<seconds>, pmltq terminates the connection
with the server and returns with a message "Evaluation of query timed
out" and exit code 2. 

=item B<--config-file|-c> filename

Specify a configuration file. The configuration file is a XML file (in
fact, a PML instance conforming to the treebase_conf_schema.xml) that
lists available SQL engine configurations. If this option is not
provided, B<pmltq> attempts to find a file named treebase.conf in the
resource paths (namely in ~/.tred.d).

=item B<--node-types>

List available node types and exit.

=item B<--netgraph-query|-N> type_name

Assume the query is in NetGraph syntax and translate it to PMLTQ,
using a given node type as the default type.

=item B<--debug|-D>

Print some extended information (e.g. evaluation benchmarks).

=back

=head2 verify

  pmltq verify <treebank_config>

Check if database exists and that it contains some data

=head2 version

  pmltq version

Print program version.

=cut


use open IO => ':utf8';
use open ':std';


use warnings;
use strict;
$|=1;
use FindBin;

use lib ($FindBin::RealBin.'/../lib', ## PMLTQ
  );

use PMLTQ;
use PMLTQ::PML2BASE;
use Treex::PML;
our $VERSION = $PMLTQ::VERSION;

use DBI;
use FindBin qw($RealBin);

use Getopt::Long;
use Pod::Usage;
use YAML::Tiny;
use File::Path qw( make_path );

Getopt::Long::Configure ("bundling");
my %error_msg = (invalid_param_n => "Invalid number of parameters !!! \n", connection => "Unable to connect to database !!!\n");

my %commands = map { $_=>1 } qw/convert delete help initdb load man query verify version/;
my $command = 'help';
my %opts;
my $dbh;
if (exists $commands{$ARGV[0]}) {
  $command = shift;
} 

if ($command eq 'query') {
  GetOptions(\%opts,
	'debug|D',
	'server|s=s',
	'command|c=s',

	'ntred|N',
	'jtred|J',
	'btred|B',
	'sql|S',
	'shared-dir|d=s',
	'keep-tmp-files',
	'filelist|l=s',

	'username=s',
	'password=s',
	'auth-id=s',

	'pmltq-extension-dir|X=s',

        'stdin',
	'query|Q=s',
        'query-id|i=s',
	'query-file|f=s',
        'query-pml-file|p=s',
	'filters|F=s',
	'no-filters',

	'netgraph-query|G=s',

	'print-servers|P',
	'config-file|c=s',

	'node-types|n',
	'relations|r',

	'limit|L=i',
	'timeout|t=i',

	'quiet|q',
	'help|h=s@',
	'usage|u',
        'version|V',
	'man',
       ) or $opts{usage}=1;
}

if ($opts{usage}) {
  pod2usage(-msg => 'pmltq');
}
if ($opts{help} || $command eq 'help') {
  $opts{help} ||= [];
  my @command_list = grep {exists $commands{$_}} (@{$opts{help}}, @ARGV);
  pod2usage(-exitstatus => 0, @command_list ? (-sections => [map {"COMMANDS/$_"} @command_list], -verbose => 99) : (-verbose => 1) );
}
if ($opts{man} || $command eq 'man') {
  pod2usage(-exitstatus => 0, -verbose => 2);
}
if ($opts{version} || $command eq 'version') {
  print "$VERSION\n";
  exit;
}

if ($command eq 'convert') {
  pod2usage(-exitstatus => 1, -sections => ["COMMANDS/$command"], -verbose => 99, -msg => $error_msg{invalid_param_n}) unless @ARGV == 2;
  my $conf = load_config($ARGV[0]);
  cmd_convert(@ARGV);
  exit;
} elsif ($command eq 'delete') {
  pod2usage(-exitstatus => 1, -sections => ["COMMANDS/$command"], -verbose => 99, -msg => $error_msg{invalid_param_n}) unless @ARGV == 1;
  cmd_delete(@ARGV);
  exit;
} elsif ($command eq 'initdb') {
  pod2usage(-exitstatus => 1, -sections => ["COMMANDS/$command"], -verbose => 99, -msg => $error_msg{invalid_param_n}) unless @ARGV == 1;
  cmd_initdb(@ARGV);
  exit;
} elsif ($command eq 'load') {
  pod2usage(-exitstatus => 1, -sections => ["COMMANDS/$command"], -verbose => 99, -msg => $error_msg{invalid_param_n}) unless @ARGV == 2;
  cmd_load(@ARGV);
  exit;
} elsif ($command eq 'verify') {
  pod2usage(-exitstatus => 1, -sections => ["COMMANDS/$command"], -verbose => 99, -msg => $error_msg{invalid_param_n}) unless @ARGV == 1;
  cmd_verify(@ARGV);
  exit;
} 

use Cwd;
use File::Spec;

use Treex::PML;
use Treex::PML::Instance;
use Treex::PML::Schema;
BEGIN {
  Treex::PML::AddResourcePath(
			 PMLTQ->resources_dir,
			 File::Spec->catfile(${FindBin::RealBin},'config'),
			 $ENV{HOME}.'/.tred.d'
			);
}
use PMLTQ::Common ':tredmacro';
use HTTP::Request::Common;
use LWP::UserAgent;
use File::Temp;
use Encode;

Treex::PML::AddBackends(qw(Storable PMLBackend PMLTransformBackend));

if ($opts{stdin}) {
  local $/;
  $opts{query} = <STDIN>;
}

$opts{$1}=1 if defined($opts{server}) and $opts{server}=~s{^[nbj]tred://}{};
my $extension_dir =
  $opts{'pmltq-extension-dir'} ||
  File::Spec->catfile($ENV{HOME},'.tred.d','extensions', 'pmltq');
Treex::PML::AddResourcePath(File::Spec->catfile($extension_dir,'resources'));

if ($command eq 'query') {
  if ($opts{ntred}) {
    ntred_search();
  } elsif ($opts{jtred}) {
    jtred_search();
  } elsif ($opts{btred}) {
    btred_search();
  } else {
    pmltq_http_search();
  }
}

my %auth;
sub pmltq_http_search {
  my $query;
  if ($opts{query} and !@ARGV) {
    $query = $opts{query};
  } elsif (!$query and @ARGV) {
    $query=join ' ',@ARGV;
  } elsif ($opts{'query-pml-file'}) {
    my $query_file = Treex::PML::Factory->createDocumentFromFile($opts{'query-pml-file'});
    die "Failed to open PML query file $opts{'query-pml-file'}: $Treex::PML::FSError\n" if $Treex::PML::FSError or !$query_file or !$query_file->trees;
    $query = first {
      !$opts{'query-id'} or $_->{id} and $_->{id} eq $opts{'query-id'}
    } $query_file->trees;
    die "Didn't find query $opts{'query-id'} in query file $opts{'query-pml-file'}!" unless $query;
    $query = encode('UTF-8',PMLTQ::Common::as_text($query));
  } elsif ($opts{'query-file'}) {
    local $/;
    open my $fh, $opts{'query-file'}
      or die "Cannot open query file '$opts{'query-file'}': $!";
    $query = <$fh>;
    if ($opts{'query-id'}) {
      $query=~s/#\s*==\s*query:\s*\Q$opts{'query-id'}\E\s* ==(.*?)(?:#\s*==\s*query:\s*\w+\s*==.*|$)/$1/s;
    }
  } elsif (!$opts{'node-types'} and !$opts{'relations'} and !$opts{'print-servers'}) {
    pod2usage(-msg => 'pmltq');
    exit 1;
  }
  if (!$opts{'query-pml-file'} and $opts{'netgraph-query'}) {
    require PMLTQ::NG2PMLTQ;
    $query = PMLTQ::NG2PMLTQ::ng2pmltq($query,{type=>$opts{'netgraph-query'}});
  }

  if (!$opts{'node-types'} and !$opts{'relations'} and !$opts{'print-servers'}) {
    die "Query is empty!" unless $query;

    my $filters = $opts{'filters'};
    if ($filters and $filters=~/\S/) {
      $filters='>> '.$filters unless $filters =~ /^\s*>>/;
      $query .= $filters;
    }
  }

  $opts{'config-file'} ||= Treex::PML::FindInResources('treebase.conf');
  if ($opts{debug}) {
    print STDERR "Reading configuration from $opts{'config-file'}\n";
  }
  my $configs = (-f $opts{'config-file'}) ?
      Treex::PML::Factory->createPMLInstance({ filename=>$opts{'config-file'} })->get_root->{configurations}
	: undef;

  my $id = $opts{'server'};
  $id ||= 'default' unless $opts{'print-servers'};
  my ($conf,$type) = $id ? get_server_conf($configs,$id) : ();
  %auth = (
    username => $opts{username},
    password => $opts{password},
   );
  if ($opts{'auth-id'}) {
    my ($auth) = get_server_conf($configs,$opts{'auth-id'});
    if ($auth) {
      $auth{$_} ||= $auth->{$_} for qw(username password);
    } else {
      die "Didn't find auth-id configuration: $opts{'auth-id'}\n";
    }
  }
  if ($conf) {
    $auth{$_} ||= $conf->{$_} for qw(username password);
  }


  if ($opts{'print-servers'}) {
    if ($opts{'server'}) {
      unless ($type eq 'http') {
	die "Cannot query available services on a $type server";
      }
      my $result='';
      http_search($conf->{url},$query,{ other=>1,
					callback => sub { $result.=$_[0] },
					debug=>$opts{debug},
					%auth,
				       });
      my @services = split /\n/,$result;
      for my $srv (@services) {
	my %srv = map { split(':',$_,2) } split /\t/, $srv;
	print $srv{id},"\t",$srv{service},"\t",$srv{title},"\n";
      }
      exit;
    }
    my @types = qw(dbi http);
    my %columns = (
      dbi => [qw(driver host port database username sources)],
      http => [qw(url username cached_description/title)],
     );
    my %configs = (
      map { my $type = $_; ($_ =>[map $_->value, grep { $_->name eq $type } SeqV($configs)]) }
	@types
       );
    for my $type (@types) {
      my $confs = $configs{$type};
      if (@$confs) {
	print uc($type)." configurations:\n";
	print (("-"x60)."\n");
	no warnings;
	for my $c (@$confs) {
	  print $c->{id}.": ".(join(", ", map "$_->[0]=$_->[1]",
				    grep length($_->[1]),
				    map [m{/(.*)} ? $1 : $_,Treex::PML::Instance::get_data($c,$_)], @{$columns{$type}})."\n");
	}
      }
      print "\n";
    }
    exit;
  }



  print STDERR $query,"\n" if $opts{debug};
  
  
  
  if ($type eq 'http') {
    http_search($conf->{url},$query,{ 'node-types'=>$opts{'node-types'},
				      'relations'=>$opts{'relations'},
				      debug=>$opts{debug},
				      %auth
				     });
  } else {
    require PMLTQ::SQLEvaluator;
    my $evaluator = PMLTQ::SQLEvaluator->new(undef,{connect => $conf, debug=>$opts{debug},
							 %auth
							});
    $evaluator->connect();
    if ($opts{'node-types'}) {
      print join "\n", @{$evaluator->get_node_types};
    } elsif ($opts{'relations'}) {
      print join "\n", @{$evaluator->get_specific_relations};
    } else {
      search($evaluator,$query);
    }
    $evaluator->{dbi}->disconnect() if $evaluator->{dbi};
  }
}

sub get_server_conf {
  my ($configs,$id)=@_;
  my ($conf,$type);
  if ($id =~ /^http:/) {
    $type = 'http';
    $conf = {url => $id};
  } else {
    my $conf_el = first { $_->value->{id} eq $id }  SeqV($configs);
    die "Didn't find server configuration named '$id'!\nUse $0 --print-servers and then $0 --server <config-id|URL>\n"
      unless $conf_el;
    $conf = $conf_el->value;
    $type = $conf_el->name;
  }
  return ($conf,$type);
}

sub http_search {
  my ($url,$query,$opts)=@_;
  $opts||={};
  my $tmp = File::Temp->new( TEMPLATE => 'pmltq_XXXXX',
			     TMPDIR => 1,
			     UNLINK => 1,
			     SUFFIX => '.txt' );
  my $ua = LWP::UserAgent->new;
  $ua->credentials(URI->new($url)->host_port,'PMLTQ',
		   $auth{username}, $auth{password})
    if $opts->{username};
  $ua->agent("PMLTQ/1.0 ");
  $url.='/' unless $url=~m{^https?://.+/};
  if ($opts->{'node-types'}) {
    $url = qq{${url}nodetypes};
    $query = '';
  } elsif ($opts->{'relations'}) {
    $url = qq{${url}relations};
    $query = '';
  } elsif ($opts->{'other'}) {
    $url = qq{${url}other};
    $query = '';
  } else {
    $url = qq{${url}query};
  }
  $ua->timeout($opts{timeout}+2) if $opts{timeout};
  my $q = $query; Encode::_utf8_off($q);
  binmode STDOUT;
  my $sub = $opts->{callback} || sub { print $_[0] };
  my $res = $ua->request(POST($url, [
      query => $q,
      format => 'text',
      limit => $opts{limit},
      row_limit => $opts{limit},
      timeout => $opts{timeout},
     ]),$sub ,1024*8 );
  unless ($res->is_success) {
    die $res->status_line."\n".$res->content."\n";
  }
}

sub search {
  my ($evaluator,$query)=@_;
  my $results;
  eval {
    $evaluator->prepare_query($query); # count=>1
    $results = $evaluator->run({
      node_limit => $opts{limit},
      row_limit => $opts{limit},
      timeout => $opts{timeout},
      timeout_callback => sub {
	print STDERR "Evaluation of query timed out\n";
	exit 2;
      },
    });
  };
  warn $@ if $@;
  if ($results) {
    for my $r (@$results) {
      print join("\t",@$r)."\n";
    }
    print STDERR $#$results+1," result(s)\n" unless $opts{quiet};
  }
}

sub quote_cmdline {
  my $quoted;
  join ' ', map {
    my $arg = $_;
    $arg =~ s{'}{'\\''}g;
    qq{'$arg'}
  } @_;
}

sub ntred_search {
  my ($host,$port)= $opts{server} ? split(/:/,$opts{server}) : ();
  my $command = $opts{command} || 'ntred';

  my $shared_dir=File::Spec->rel2abs($opts{'shared-dir'} || '.');
  my $filter_file="$shared_dir/pmltq_ntred_filter.$$.pl";

  my @script_flags=('--filter-code-out', $filter_file);
  foreach (qw(query query-id query-file query-pml-file filters netgraph-query)) {
    push @script_flags, '--'.$_, (/file/ ? File::Spec->rel2abs($opts{$_}) : $opts{$_})
      if defined($opts{$_}) and length($opts{$_});
  }

  $command .= ' '.quote_cmdline(
    ((defined($host) and length($host)) ? ('--hub',$host) : ()),
    ((defined($port) and length($port)) ? ('--port',$port) : ()),
    '-q',
    '-I', File::Spec->catfile($extension_dir,qw(contrib pmltq pmltq.ntred)),
    ($opts{filelist} ? ('-l', File::Spec->rel2abs($opts{filelist})) : (@ARGV ? ('-L', '--', @ARGV) : ())),
    '--', @script_flags
  );
  open(my $pipe, $command.' | ') || die "Failed to start ntred client: $!";
  apply_filter($pipe, $filter_file);
  close($pipe);
  unlink $filter_file if -f $filter_file and !$opts{'keep-tmp-files'};
}

sub jtred_search {
  my $command = $opts{command} || 'jtred';

  my $jobname="pmltq_jtred_$$";
  if ($opts{server}) {
    $jobname.="-".$ENV{HOSTNAME};
  }

  my $shared_dir=File::Spec->rel2abs($opts{'shared-dir'} || '.');
  my $filter_file="$shared_dir/$jobname.pl";
  my $filelist;
  if ($opts{filelist}) {
    my ($vol,$dir) = File::Spec->splitpath($opts{filelist});
    my $base = File::Spec->catpath($vol,$dir);
    open my $fh, '<', $opts{filelist} or die "Cannot open filelist $opts{filelist}: $!";
    $filelist = "$shared_dir/$jobname.fl";
    open my $out_fh, '>', $filelist or die "Cannot create temporary filelist $filelist: $!";
    print STDERR "Resolving filelist files to $base...\n" unless $opts{quiet};
    while(<$fh>) {
      chomp;
      print $out_fh File::Spec->rel2abs($_,$base),"\n";
    }
    print STDERR "done.\n" unless $opts{quiet};
    close $fh;
    close $out_fh;
  }
  my @script_flags=('--filter-code-out', $filter_file);
  foreach (qw(query query-id query-file query-pml-file filters netgraph-query)) {
    push @script_flags, '--'.$_, (/file/ ? File::Spec->rel2abs($opts{$_}) : $opts{$_})
      if defined($opts{$_}) and length($opts{$_});
  }
  my @command = (
    $command,
    ($opts{'shared-dir'} ? ('-jw', $shared_dir) : ()),
    '-jn', $jobname,
    ($opts{quiet} ? '-jq' : ()),
    ($filelist ? ('-l', $filelist) : @ARGV),
    '-jb',
    '-q',
    '-I', File::Spec->catfile($extension_dir,qw(contrib pmltq pmltq.ntred)),
    '-o',  @script_flags, '--'
  );
  my $pipe;
  if ($opts{server}) {
    my $cwd = quote_cmdline(getcwd());
    open($pipe, '-|', 'ssh', $opts{server}, <<"SCRIPT".quote_cmdline(@command))
if [ -f ~/.bash_profile ]; then
   . ~/.bash_profile 2>/dev/null 1>&2
elif [ -f ~/.profile ]; then
   . ~/.profile 2>/dev/null 1>&2
fi
cd $cwd;
SCRIPT
      || die "Failed to start jtred on host $opts{server} over ssh: $!"
  } else {
    open($pipe, '-|',@command)
      || die "Failed to start jtred: $!";
  }
  apply_filter($pipe, $filter_file);
  close($pipe);
  unlink $filter_file if -f $filter_file and !$opts{'keep-tmp-files'};
  unlink $filelist if $filelist and !$opts{'keep-tmp-files'};
}

sub btred_search {
  my $command = $opts{command} || 'btred';

  my $jobname="pmltq_btred_$$";
  if ($opts{server}) {
    $jobname.="-".$ENV{HOSTNAME};
  }

  my $shared_dir=File::Spec->rel2abs($opts{'shared-dir'} || '.');
  my $filter_file="$shared_dir/$jobname.pl";

  my @script_flags=('--filter-code-out', $filter_file);
  foreach (qw(query query-id query-file query-pml-file filters netgraph-query)) {
    push @script_flags, '--'.$_, (/file/ ? File::Spec->rel2abs($opts{$_}) : $opts{$_})
      if defined($opts{$_}) and length($opts{$_});
  }
  for (qw(node-types relations)) {
    if ($opts{$_}) {
      push @script_flags, '--info', $_;
      last;
    }
  }

  $command .= ' '.quote_cmdline(
    ($opts{quiet} ? '-Q' : '-q'),
    '-I', File::Spec->catfile($extension_dir,qw(contrib pmltq pmltq.ntred)),
    '-o', '--apply-filters', @script_flags, '--',
    ($opts{filelist} ? ('-l', $opts{filelist}) : @ARGV),
  );
  if ($opts{server}) {
    my $cwd = quote_cmdline(getcwd());
    system('ssh', $opts{server}, <<"SCRIPT");
if [ -f ~/.bash_profile ]; then
   . ~/.bash_profile
elif [ -f ~/.profile ]; then
   . ~/.profile;
fi
cd $cwd
$command
SCRIPT
  } else {
    system($command);
  }
  unlink $filter_file if -f $filter_file and !$opts{'keep-tmp-files'};
}


sub round {
  my ($value, $precision) = @_;
  my $rounding = ($value >= 0 ? 0.5 : -0.5);
  my $decimalscale = 10**int($precision || 0);
  my $scaledvalue = int($value * $decimalscale + $rounding);
  return $scaledvalue / $decimalscale;
}

sub trunc {
  my ($self, $num, $digits) = @_;
  $digits = int $digits;
  my $decimalscale = 10**abs($digits);
  if ($digits >= 0) {
    return int($num * $decimalscale) / $decimalscale;
  } else {
    return int($num / $decimalscale) * $decimalscale;
  }
}

sub apply_filter {
  my ($input, $filter_file)=@_;
  my $filters;
  my $filter;
  my $first = 1;
  use POSIX qw(ceil floor);

  if ($opts{'no-filters'}) {
    print while (<$input>);
    return;
  }

  my $output_filter = {
    init => sub { },
    process_row => sub {
      my ($self,$row)=@_;
      print(join("\t",@$row)."\n");
    },
    finish => sub { }
   };

  while (<$input>) {
    chomp;
    unless ($filter) {
      if (-f $filter_file and -s $filter_file) {
	open my $fh, "<", $filter_file or
	  die "Cannot open $filter_file: $!";
	my $filter_code;
	{
	  local $/;
	  $filter_code = <$fh>;
	}
	eval "use utf8;\n".$filter_code;
	if ($@) {
	  print STDERR $filter_code;
	  print STDERR "\n";
	  die "Running filter $filter_file failed!";
	}
	my @filters = map {
	  my @local_filters = map eval, @{$_->{local_filters_code}};
	  my $sub = eval($_->{code});
	  die $@ if $@;
	  $sub
	} @$filters;

	# connect filters
	my $prev;
	for my $filter (@filters) {
	  $prev->{output}=$filter if $prev;
	  $prev = $filter;
	}
	if ($prev) {
	  $prev->{output} = $output_filter;
	}
	$filter = $filters[0] || die "First filter is empty!";
	$filter->{init}->($filter);
      } else {
	$filter = $output_filter;
      }
    }
    $filter->{process_row}->($filter,[split /\t/,$_]);
  }
  $filter->{finish}->($filter) if $filter;
}

sub load_config {
  my $config_file = shift;
  my $data;
  eval {$data = YAML::Tiny->read($config_file)};
  if ($@ && $@ =~ m/YAML_LOAD_ERR/) {
    print STDERR "unable to load config file '$config_file'\n";
  } elsif ($@ && $@ =~ m/YAML_PARSE_ERR/) {
    $@ =~ s/\n.*//g;
    print STDERR "unable to parse config file '$config_file'\n\t$@\n";
  } elsif (! $data) {
    print STDERR "unable to open config file '$config_file'\n";
  }
  exit unless $data;
  $data->[0]->{db}->{driver} ||= 'Pg';
  return $data->[0];
}

sub db_connect {
  my $config = shift;
  my $dbname = shift || $config->{db}->{name};
  die "Database driver ".$config->{db}->{driver}." is not supported !!!\n" unless $config->{db}->{driver} eq 'Pg';
  my $dbh_ = DBI->connect("DBI:".$config->{db}->{driver}.":dbname=$dbname;host=".$config->{db}->{host}.";port=".$config->{db}->{port}, 
    $config->{db}->{user}, 
    $config->{db}->{password}, 
    { RaiseError => 1, PrintError => 1, mysql_enable_utf8 => 1 }) or die "$error_msg{connection}\n$DBI::errstr";
  return $dbh_;
}

sub db_disconnect {
  my $dbh_ = shift;
  $dbh_->disconnect();
}

sub cmd_convert {
  my $config = load_config(shift);
  my $sqldir = shift;
  if(!-d $sqldir) {
    make_path($sqldir) or die "Unable to create directory $sqldir\n";
  }
  Treex::PML::AddResourcePath($config->{resources});
  for my $layer (@{$config->{layers}}) {
    print STDERR "==== Converting data for layer $layer->{name}\n";
    PMLTQ::PML2BASE::init();
    $PMLTQ::PML2BASE::opts{'no-secondary-files'} = 1;
    $PMLTQ::PML2BASE::opts{'resource-dir'} = $config->{resources};
    $PMLTQ::PML2BASE::opts{'syntax'} = 'postgres';
    $PMLTQ::PML2BASE::opts{'loader'} = 'file_list'; # SH
    $PMLTQ::PML2BASE::opts{'data-dir'} = $config->{data_dir};
    $PMLTQ::PML2BASE::opts{'output-dir'} = $sqldir;
    %{$PMLTQ::PML2BASE::opts{'ref'}}=();
    $PMLTQ::PML2BASE::opts{'ref'}{$_} = $layer->{'references'}{$_} for (keys %{$layer->{'references'}||{}});
    #$PMLTQ::PML2BASE::opts{'debug'} = 1;

    # converting schema from pml2base.btred
    # PMLTQ::PML2BASE::convert_schema(Treex::PML::Factory->createPMLSchema({filename=>$opts{schema},use_resources=>1}),
    #                       {%opts, # $opts{ref} contains references
    #                        ($opts{'no-eparents'}&&$opts{'no-a-rf'}) ? () : (for_schema => \&mk_extra_tables),
    #                       });
    # PMLTQ::PML2BASE::dump_typemap();
    # end of converting schema


    for my $file (glob(File::Spec->catfile($config->{data_dir}, $layer->{data}))) {
      print STDERR "$file\n";
      my $fsfile = Treex::PML::Factory->createDocumentFromFile($file);
      if ($Treex::PML::FSError) {
        die "Error loading file $file: $Treex::PML::FSError ($!)\n";
      }
      PMLTQ::PML2BASE::fs2base($fsfile, {
                      for_each_tree => \&PMLTQ::Common::Effective::dump_eparent, ## TODO: not for all treebanks !!!
                      for_schema => \&PMLTQ::Common::Effective::mk_extra_tables  ##
                    });
    }
    PMLTQ::PML2BASE::finish();
    PMLTQ::PML2BASE::destroy();
  }
}


sub cmd_delete {
  my $config = load_config(shift);
  $dbh = db_connect($config,'postgres');
  $dbh->do("DROP DATABASE ".$config->{db}->{name});
  db_disconnect($dbh);
}


sub cmd_initdb {
  my $config = load_config(shift);
  $dbh = db_connect($config,'postgres');
  $dbh->do("CREATE DATABASE ".$config->{db}->{name});
  $dbh = db_connect($config);
  for my $file (qw/init_postgres.sql pml2base_init-pg.sql/) {
    run_sql_from_file($file,File::Spec->catfile(PMLTQ->shared_dir,"sql"));
  }
  db_disconnect($dbh);
}
  

sub cmd_load {
  my $conf = shift;
  my $config = load_config($conf);
  my $sqldir = shift;
  if(!-d $sqldir) {
    die "Directory $sqldir does not exist\n";
  }
  $dbh = db_connect($config);
  for my $layer (@{$config->{layers}}) {
    my $listfile = "$sqldir$layer->{name}__init.list";
    open my $fh, '<', $listfile or die "Can't open $listfile: $!";
    for my $file (<$fh>) {
      $file =~ s/\n$//;
      next unless $file;
      run_sql_from_file($file,$sqldir);
    }
    ###$dbh->do($sql);
  }
  db_disconnect($dbh);
}


sub cmd_verify {
  my $config = load_config(shift);
  eval { $dbh = db_connect($config)};
  die "Database ".$config->{db}->{name}." does not exist !!!\n" if $@;
  print "Database ".$config->{db}->{name}." exists\n";
  my @tables = map {s/^public\.//;$_} grep {m/^public\./} $dbh->tables();
  print "Database contains ", scalar @tables, " tables\n";
  for my $table (@tables) {
    my $sth = $dbh->prepare("SELECT * FROM $table");
    $sth->execute;
    print "Table $table contains ".$sth->rows." rows\n";
  }
  db_disconnect($dbh);
}

sub run_sql_from_file {
  my $file = shift;
  my $dir = shift;
  my $sqlfile = File::Spec->catfile($dir,$file);
  my $sql = do {
      open my $fh, '<', $sqlfile or die "Can't open $sqlfile: $!";
      local $/;
      <$fh>
    };
  if($file =~ m/.ctl/ && $sql =~ m/(COPY .*? FROM *?["'].*?["'])/g ) {
    die "more copy commands than one in file is not supported" if @_ > 1;
    $sql =~ s/(COPY .*? FROM) *?["'](.*?)["']/$1 STDIN/;
    my $dump_file = File::Spec->catfile($dir,$2);
    my $data = do {
        open my $fh, '<', "$dump_file" or die "Can't open $dump_file: $!";
        local $/;
        <$fh>
      };
    eval {
      $dbh->do($sql);
      $dbh->pg_putcopydata("$_\n") for (split(/\n/,$data));
      $dbh->pg_putcopyend();
    };
    warn $@ if $@;
  } else {
    print STDERR "RUNNING SQL FROM $file\n";
    for my $s (split(/;\s*\n/, $sql)) {
      eval {$dbh->do("$s;");};
    }
  }
}






package PMLTQ::Common::Effective;


sub mk_extra_tables {
  mk_eparent_table(@_) unless $opts{'no-eparents'};
  mk_a_rf_table(@_) unless $opts{'no-a-rf'};
}

sub mk_a_rf_table {
  my ($schema,$desc,$fh)=@_;
  my $name = $schema->get_root_name;
  my $table_name = PMLTQ::PML2BASE::rename_type($name);
  unless ($opts{'no-schema'}) {
    if ($name =~ /^tdata/) {
      $fh->{'#INIT_SQL'}->print(<<"EOF");
CREATE TABLE "${table_name}__#a_rf" ("#idx" INT, "#value" INT);
CREATE INDEX "#Ui_${table_name}_a_rf0" ON "${table_name}__#a_rf" ("#idx");
CREATE INDEX "#Ui_${table_name}_a_rf1" ON "${table_name}__#a_rf" ("#value");
INSERT INTO "#PML_USR_REL" VALUES('a/lex.rf|a/aux.rf',NULL,'t-node','a-node','${table_name}__#a_rf');
EOF

      $fh->{'#DELETE_SQL'}->print(<<"EOF");
DROP TABLE "${table_name}__#a_rf";
DELETE FROM "#PML_USR_REL" WHERE "tbl"='${table_name}__#a_rf';
EOF
      $fh->{'#POST_SQL'}->print(<<"EOF");
INSERT INTO "${table_name}__#a_rf"
  SELECT t."#idx" AS "#idx", a."lex" AS "#value"
    FROM "t-node" t JOIN "t-a" a ON a."#idx"=t."a"
  UNION
  SELECT t."#idx" AS "#idx", aux."#value" AS "#value"
    FROM "t-node" t JOIN "t-a" a ON a."#idx"=t."a" JOIN "t-a/aux.rf" aux ON aux."#idx"=a."aux.rf"
  UNION
  SELECT r."#idx" AS "#idx", r."atree" FROM "t-root" r;
EOF
    }
  }
}

sub mk_eparent_table {
    my ($schema,$desc,$fh)=@_;
    my $name = $schema->get_root_name;
    my @tables;
    my $table_name = PMLTQ::PML2BASE::rename_type($name.'__#eparents');
    print "mk_eparent_table\n";

    if ($name eq 'treex_document') {
        ## init tables for both tdata and adata because
        ## treex_documents contains all trees in one document
        my $adata_c_table = PML2BASE::rename_type($name.'__adata#eparents_c');
        my $adata_table = PML2BASE::rename_type($name.'__adata#eparents');
        my $tdata_table = PML2BASE::rename_type($name.'__tdata#eparents');
        unless ($opts{'no-schema'}) {
            $fh->{'#INIT_SQL'}->print(<<"EOF");
INSERT INTO "#PML_USR_REL" VALUES('eparentC','echildC','a-node','a-node','${adata_c_table}');
INSERT INTO "#PML_USR_REL" VALUES('eparent','echild','a-node','a-node','${adata_table}');
INSERT INTO "#PML_USR_REL" VALUES('eparent','echild','t-node','t-node','${tdata_table}');
EOF
            $fh->{'#DELETE_SQL'}->print(<<"EOF");
DELETE FROM "#PML_USR_REL" WHERE "tbl"='${adata_table}';
DELETE FROM "#PML_USR_REL" WHERE "tbl"='${tdata_table}';
EOF
        }

        @tables = ($adata_table, $tdata_table, $adata_c_table);

    } else {
        @tables = ($table_name);

        unless ($opts{'no-schema'}) {
            my $node_type;
            if ($name =~ /^tdata/) {
                $node_type = 't-node';
            } elsif ($name =~ /^adata/) {
                $node_type = 'a-node';
            }

            if ($node_type) {
                my $node_table  = PMLTQ::PML2BASE::rename_type($node_type);
                $fh->{'#INIT_SQL'}->print(<<"EOF");
INSERT INTO "#PML_USR_REL" VALUES('eparent','echild','${node_type}','${node_type}','${table_name}');
EOF
                $fh->{'#DELETE_SQL'}->print(<<"EOF");
DELETE FROM "#PML_USR_REL" WHERE "tbl"='${table_name}';
EOF
            }
        }

    }

    for my $table (@tables) {
        $desc->{$table} = {
            table => $table,
            colspec => [
                ['#idx','INT'],
                ['#value','INT'],
            ],
            index => ["#idx","#value"]
        };
        open $fh->{$table},'>',PMLTQ::PML2BASE::get_full_path(PMLTQ::PML2BASE::to_filename($table));
    }
}

sub dump_eparent {
    my ($tree,$hash,$fh)=@_;
    my $name = $tree->type->get_schema->get_root_name;
    my $table_name = PMLTQ::PML2BASE::rename_type($name.'__#eparents');
    if ($name =~ /^adata/) {
        for my $node ($tree->descendants) {
            for my $p (PMLTQ::Common::Effective::PML_A::GetEParents($node,\&PMLTQ::Common::Effective::PML_A::DiveAuxCP)) {
                $fh->{$table_name}->print(PMLTQ::PML2BASE::mkdump($hash->{$node}{'#idx'},$hash->{$p}{'#idx'}));
            }
        }
    } elsif ($name =~ /^tdata/) {
        for my $node ($tree->descendants) {
            for my $p (PMLTQ::Common::Effective::PML_T::GetEParents($node)) {
                $fh->{$table_name}->print(PMLTQ::PML2BASE::mkdump($hash->{$node}{'#idx'},$hash->{$p}{'#idx'}));
            }
        }
    } elsif ($name eq 'treex_document' ) {
        my $adata_c_table = PMLTQ::PML2BASE::rename_type($name.'__adata#eparents_c');
        my $adata_table = PMLTQ::PML2BASE::rename_type($name.'__adata#eparents');
        my $tdata_table = PMLTQ::PML2BASE::rename_type($name.'__tdata#eparents');
        my $struct_name = $tree->type->get_structure_name||'';
        if ($struct_name eq 'a-root') {
            foreach my $anode ($tree->descendants) {
                foreach my $p (PMLTQ::Common::Effective::TreexUtils::AGetEParentsC($anode)) {
                    $fh->{$adata_c_table}->print(PMLTQ::PML2BASE::mkdump($hash->{$anode}{'#idx'}, $hash->{$p}{'#idx'}));
                }
                foreach my $p (PMLTQ::Common::Effective::TreexUtils::AGetEParents($anode)) {
                    $fh->{$adata_table}->print(PMLTQ::PML2BASE::mkdump($hash->{$anode}{'#idx'}, $hash->{$p}{'#idx'}));
                }
            }
        } elsif ($struct_name eq 't-root') {
            foreach my $tnode ($tree->descendants) {
                foreach my $p (PMLTQ::Common::Effective::TreexUtils::TGetEParents($tnode)) {
                    $fh->{$tdata_table}->print(PMLTQ::PML2BASE::mkdump($hash->{$tnode}{'#idx'}, $hash->{$p}{'#idx'}));
                }
            }
        }
    }
}

package PMLTQ::Common::Effective::TreexUtils;
sub AGetEParentsC {
  return shift->get_eparents({or_topological => 1, ignore_incorrect_tree_structure => 1, ordered => 1});
}

sub AGetEChildrenC {
  return shift->get_echildren({or_topological => 1, ignore_incorrect_tree_structure => 1, ordered => 1});
}

sub AGetEParents {
  return shift->get_eparents({dive => 'AuxCP', or_topological => 1, ignore_incorrect_tree_structure => 1, ordered => 1});
}

sub AGetEChildren {
  return shift->get_echildren({dive => 'AuxCP', or_topological => 1, ignore_incorrect_tree_structure => 1, ordered => 1});
}

sub TGetEChildren {
  return shift->get_echildren({or_topological => 1, ignore_incorrect_tree_structure => 1, ordered => 1});
}

sub TGetEParents {
  return shift->get_eparents({or_topological => 1, ignore_incorrect_tree_structure => 1, ordered => 1});
}





package PMLTQ::Common::Effective::PML_A;

=item DiveAuxCP($node)

You can use this function as a C<through> argument to GetEParents and
GetEChildren. It skips all the prepositions and conjunctions when
looking for nodes which is what you usually want.

=cut

sub DiveAuxCP ($){
  $_[0]->{afun}=~/^Aux[CP]/ ? 1 : 0;
}#DiveAuxCP

=item GetEParents($node,$through)

Return linguistic parent of a given node as appears in an analytic
tree. The argument C<$through> should supply a function accepting one
node as an argument and returning true if the node should be skipped
on the way to parent or 0 otherwise. The most common C<DiveAuxCP> is
provided in this package.

=cut

sub _ExpandCoordGetEParents { # node through
  my ($node,$through)=@_;
  my @toCheck = $node->children;
  my @checked;
  while (@toCheck) {
    @toCheck=map {
      if (&$through($_)) { $_->children() }
      elsif($_->{afun}=~/Coord|Apos/&&$_->{is_member}){ _ExpandCoordGetEParents($_,$through) }
      elsif($_->{is_member}){ push @checked,$_;() }
      else{()}
    }@toCheck;
  }
  return @checked;
}# _ExpandCoordGetEParents

sub GetEParents { # node through
  my ($node,$through)=@_;
  my $init_node = $node; # only used for reporting errors
  return() if !$node or $node->{afun}=~/^(?:Coord|Apos|Aux[SCP])$/;
  if ($node->{is_member}) { # go to coordination head
    while ($node->{afun}!~/Coord|Apos|AuxS/ or $node->{is_member}) {
      $node=$node->parent;
      if (!$node) {
  print STDERR
    "GetEParents: Error - no coordination head $init_node->{AID}: ".ThisAddress($init_node)."\n";
        return();
      } elsif($node->{afun}eq'AuxS') {
  print STDERR
    "GetEParents: Error - no coordination head $node->{AID}: ".ThisAddress($node)."\n";
        return();
      }
    }
  }
  if (&$through($node->parent)) { # skip 'through' nodes
    while ($node and &$through($node->parent)) {
      $node=$node->parent;
    }
  }
  return unless $node;
  $node=$node->parent;
  return unless $node;
  return $node if $node->{afun}!~/Coord|Apos/;
  _ExpandCoordGetEParents($node,$through);
} # GetEParents






package PMLTQ::Common::Effective::PML_T;

=item ExpandCoord($node,$keep?)

If the given node is coordination or aposition (according to its TGTS
functor - attribute C<functor>) expand it to a list of coordinated
nodes. Otherwise return the node itself. If the argument C<keep> is
true, include the coordination/aposition node in the list as well.

=cut

sub ExpandCoord {
  my ($node,$keep)=@_;
  return unless $node;
  if (IsCoord($node)) {
    return (($keep ? $node : ()),
      map { ExpandCoord($_,$keep) }
      grep { $_->{is_member} } $node->children);
  } else {
    return ($node);
  }
} #ExpandCoord

=item IsCoord($node?)

Check if the given node is a coordination according to its TGTS
functor (attribute C<functor>)

=cut

sub IsCoord {
  my $node=$_[0]//undef;# || $this;
  return 0 unless $node;
  return $node->{functor} =~ /ADVS|APPS|CONFR|CONJ|CONTRA|CSQ|DISJ|GRAD|OPER|REAS/;
}

=item GetEParents($node)

Return linguistic parents of a given node as appear in a TG tree.

=cut

sub GetEParents {
  my $node = $_[0];# || $this;
  return() if IsCoord($node);
  if ($node and $node->{is_member}) {
    while ($node and (!IsCoord($node) or $node->{is_member})) {
      $node=$node->parent;
    }
  }
  return () unless $node;
  $node=$node->parent;
  return () unless $node;
  return ($node) if !IsCoord($node);
  return (ExpandCoord($node));
} # GetEParents
