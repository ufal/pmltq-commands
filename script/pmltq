#!/usr/bin/env perl
# pmltq     pajas@ufal.mff.cuni.cz     2008/07/08 08:34:19

# ABSTRACT: Command line interface to PML-TQ

=head1 SYNOPSIS

  pmltq <command> [<args>]

or

  pmltq -P               for a list of configured connections
  pmltq -u               for usage
  pmltq -h <commandlist> for help
  pmltq --man            for the manual page
  pmltq --version        for version

  Available pmltq commands
    convert
    delete
    help
    initdb
    load
    man
    query
    verify
    version


=head1 DESCRIPTION

B<pmltq> is a command-line interface to PML-TQ. It can use either a
SQL-based query engine, btred, ntred, or jtred (btred over a SGE
cluster) to evaluate the query. The results are printed to the
standard output.

=head1 OPTIONS

=over 5

=item B<--print-servers|-P>

Print list of configured query server connections and exit. If a HTTP
service is specified using the --server option, the service is
contacted to provide a list of all other public PML-TQ services
running on the same server for which the user is authorized.

=item B<--usage|-u>

Print a brief help message on usage and exits.

=item B<--help|-h <commandlist>>

Prints the help page and exits.

=item B<--man>

Displays the help as manual page.

=item B<--version>

Print program version.

=back

=cut


use open IO => ':utf8';
use open ':std';

use warnings;
use strict;
$|=1;
use FindBin;

use lib ($FindBin::RealBin.'/../lib', ## PMLTQ
  );

use PMLTQ;
use PMLTQ::PML2BASE;
use PMLTQ::Commands;
use Treex::PML;
our $VERSION = $PMLTQ::VERSION;

use DBI;
use FindBin qw($RealBin);

use Getopt::Long;
use Pod::Usage;
use YAML::Tiny;
use File::Path qw( make_path );

Getopt::Long::Configure ("bundling");
my %error_msg = (invalid_param_n => "Invalid number of parameters !!! \n", connection => "Unable to connect to database !!!\n");
my %opts;


PMLTQ::Commands->run(@ARGV);




=x
if ($opts{usage}) {
  pod2usage(-msg => 'pmltq');
}
if ($opts{help} || $command eq 'help') {
  $opts{help} ||= [];
  my @command_list = grep {exists $commands{$_}} (@{$opts{help}}, @ARGV);
  pod2usage(-exitstatus => 0, @command_list ? (-sections => [map {"COMMANDS/$_"} @command_list], -verbose => 99) : (-verbose => 1) );
}
if ($opts{man} || $command eq 'man') {
  pod2usage(-exitstatus => 0, -verbose => 2);
}
if ($opts{version} || $command eq 'version') {
  print "$VERSION\n";
  exit;
}



if ($command eq 'convert') {
  pod2usage(-exitstatus => 1, -sections => ["COMMANDS/$command"], -verbose => 99, -msg => $error_msg{invalid_param_n}) unless @ARGV == 2;
  my $conf = load_config($ARGV[0]);
  cmd_convert(@ARGV);
  exit;
} elsif ($command eq 'delete') {
  pod2usage(-exitstatus => 1, -sections => ["COMMANDS/$command"], -verbose => 99, -msg => $error_msg{invalid_param_n}) unless @ARGV == 1;
  cmd_delete(@ARGV);
  exit;
} elsif ($command eq 'initdb') {
  pod2usage(-exitstatus => 1, -sections => ["COMMANDS/$command"], -verbose => 99, -msg => $error_msg{invalid_param_n}) unless @ARGV == 1;
  cmd_initdb(@ARGV);
  exit;
} elsif ($command eq 'load') {
  pod2usage(-exitstatus => 1, -sections => ["COMMANDS/$command"], -verbose => 99, -msg => $error_msg{invalid_param_n}) unless @ARGV == 2;
  cmd_load(@ARGV);
  exit;
} elsif ($command eq 'verify') {
  pod2usage(-exitstatus => 1, -sections => ["COMMANDS/$command"], -verbose => 99, -msg => $error_msg{invalid_param_n}) unless @ARGV == 1;
  cmd_verify(@ARGV);
  exit;
} 
=cut



package PMLTQ::Common::Effective::TreexUtils;
sub AGetEParentsC {
  return shift->get_eparents({or_topological => 1, ignore_incorrect_tree_structure => 1, ordered => 1});
}

sub AGetEChildrenC {
  return shift->get_echildren({or_topological => 1, ignore_incorrect_tree_structure => 1, ordered => 1});
}

sub AGetEParents {
  return shift->get_eparents({dive => 'AuxCP', or_topological => 1, ignore_incorrect_tree_structure => 1, ordered => 1});
}

sub AGetEChildren {
  return shift->get_echildren({dive => 'AuxCP', or_topological => 1, ignore_incorrect_tree_structure => 1, ordered => 1});
}

sub TGetEChildren {
  return shift->get_echildren({or_topological => 1, ignore_incorrect_tree_structure => 1, ordered => 1});
}

sub TGetEParents {
  return shift->get_eparents({or_topological => 1, ignore_incorrect_tree_structure => 1, ordered => 1});
}




