#!/usr/bin/env perl
# pmltq     pajas@ufal.mff.cuni.cz     2008/07/08 08:34:19

# ABSTRACT: Command line interface to PML-TQ

=head1 SYNOPSIS

  pmltq <command> [<args>]

or

  pmltq -P               for a list of configured connections
  pmltq -u               for usage
  pmltq -h <commandlist> for help
  pmltq --man            for the manual page
  pmltq --version        for version

  Available pmltq commands
    convert
    delete
    help
    initdb
    load
    man
    query
    verify
    version


=head1 DESCRIPTION

B<pmltq> is a command-line interface to PML-TQ. It can use either a
SQL-based query engine, btred, ntred, or jtred (btred over a SGE
cluster) to evaluate the query. The results are printed to the
standard output.

=head1 OPTIONS

=over 5

=item B<--print-servers|-P>

Print list of configured query server connections and exit. If a HTTP
service is specified using the --server option, the service is
contacted to provide a list of all other public PML-TQ services
running on the same server for which the user is authorized.

=item B<--usage|-u>

Print a brief help message on usage and exits.

=item B<--help|-h <commandlist>>

Prints the help page and exits.

=item B<--man>

Displays the help as manual page.

=item B<--version>

Print program version.

=back

=cut


use open IO => ':utf8';
use open ':std';

use warnings;
use strict;
$|=1;
use FindBin;

use lib ($FindBin::RealBin.'/../lib', ## PMLTQ
  );

use PMLTQ;
use PMLTQ::PML2BASE;
use PMLTQ::Commands;
use Treex::PML;
our $VERSION = $PMLTQ::VERSION;

use DBI;
use FindBin qw($RealBin);

use Getopt::Long;
use Pod::Usage;
use YAML::Tiny;
use File::Path qw( make_path );

Getopt::Long::Configure ("bundling");
my %error_msg = (invalid_param_n => "Invalid number of parameters !!! \n", connection => "Unable to connect to database !!!\n");
my %opts;


PMLTQ::Commands->run(@ARGV);




=x
if ($opts{usage}) {
  pod2usage(-msg => 'pmltq');
}
if ($opts{help} || $command eq 'help') {
  $opts{help} ||= [];
  my @command_list = grep {exists $commands{$_}} (@{$opts{help}}, @ARGV);
  pod2usage(-exitstatus => 0, @command_list ? (-sections => [map {"COMMANDS/$_"} @command_list], -verbose => 99) : (-verbose => 1) );
}
if ($opts{man} || $command eq 'man') {
  pod2usage(-exitstatus => 0, -verbose => 2);
}
if ($opts{version} || $command eq 'version') {
  print "$VERSION\n";
  exit;
}



if ($command eq 'convert') {
  pod2usage(-exitstatus => 1, -sections => ["COMMANDS/$command"], -verbose => 99, -msg => $error_msg{invalid_param_n}) unless @ARGV == 2;
  my $conf = load_config($ARGV[0]);
  cmd_convert(@ARGV);
  exit;
} elsif ($command eq 'delete') {
  pod2usage(-exitstatus => 1, -sections => ["COMMANDS/$command"], -verbose => 99, -msg => $error_msg{invalid_param_n}) unless @ARGV == 1;
  cmd_delete(@ARGV);
  exit;
} elsif ($command eq 'initdb') {
  pod2usage(-exitstatus => 1, -sections => ["COMMANDS/$command"], -verbose => 99, -msg => $error_msg{invalid_param_n}) unless @ARGV == 1;
  cmd_initdb(@ARGV);
  exit;
} elsif ($command eq 'load') {
  pod2usage(-exitstatus => 1, -sections => ["COMMANDS/$command"], -verbose => 99, -msg => $error_msg{invalid_param_n}) unless @ARGV == 2;
  cmd_load(@ARGV);
  exit;
} elsif ($command eq 'verify') {
  pod2usage(-exitstatus => 1, -sections => ["COMMANDS/$command"], -verbose => 99, -msg => $error_msg{invalid_param_n}) unless @ARGV == 1;
  cmd_verify(@ARGV);
  exit;
} 
=cut


package PMLTQ::Common::Effective;


sub dump_eparent {
    my ($tree,$hash,$fh)=@_;
    my $name = $tree->type->get_schema->get_root_name;
    my $table_name = PMLTQ::PML2BASE::rename_type($name.'__#eparents');
    if ($name =~ /^adata/) {
        for my $node ($tree->descendants) {
            for my $p (PMLTQ::Common::Effective::PML_A::GetEParents($node,\&PMLTQ::Common::Effective::PML_A::DiveAuxCP)) {
                $fh->{$table_name}->print(PMLTQ::PML2BASE::mkdump($hash->{$node}{'#idx'},$hash->{$p}{'#idx'}));
            }
        }
    } elsif ($name =~ /^tdata/) {
        for my $node ($tree->descendants) {
            for my $p (PMLTQ::Common::Effective::PML_T::GetEParents($node)) {
                $fh->{$table_name}->print(PMLTQ::PML2BASE::mkdump($hash->{$node}{'#idx'},$hash->{$p}{'#idx'}));
            }
        }
    } elsif ($name eq 'treex_document' ) {
        my $adata_c_table = PMLTQ::PML2BASE::rename_type($name.'__adata#eparents_c');
        my $adata_table = PMLTQ::PML2BASE::rename_type($name.'__adata#eparents');
        my $tdata_table = PMLTQ::PML2BASE::rename_type($name.'__tdata#eparents');
        my $struct_name = $tree->type->get_structure_name||'';
        if ($struct_name eq 'a-root') {
            foreach my $anode ($tree->descendants) {
                foreach my $p (PMLTQ::Common::Effective::TreexUtils::AGetEParentsC($anode)) {
                    $fh->{$adata_c_table}->print(PMLTQ::PML2BASE::mkdump($hash->{$anode}{'#idx'}, $hash->{$p}{'#idx'}));
                }
                foreach my $p (PMLTQ::Common::Effective::TreexUtils::AGetEParents($anode)) {
                    $fh->{$adata_table}->print(PMLTQ::PML2BASE::mkdump($hash->{$anode}{'#idx'}, $hash->{$p}{'#idx'}));
                }
            }
        } elsif ($struct_name eq 't-root') {
            foreach my $tnode ($tree->descendants) {
                foreach my $p (PMLTQ::Common::Effective::TreexUtils::TGetEParents($tnode)) {
                    $fh->{$tdata_table}->print(PMLTQ::PML2BASE::mkdump($hash->{$tnode}{'#idx'}, $hash->{$p}{'#idx'}));
                }
            }
        }
    }
}

package PMLTQ::Common::Effective::TreexUtils;
sub AGetEParentsC {
  return shift->get_eparents({or_topological => 1, ignore_incorrect_tree_structure => 1, ordered => 1});
}

sub AGetEChildrenC {
  return shift->get_echildren({or_topological => 1, ignore_incorrect_tree_structure => 1, ordered => 1});
}

sub AGetEParents {
  return shift->get_eparents({dive => 'AuxCP', or_topological => 1, ignore_incorrect_tree_structure => 1, ordered => 1});
}

sub AGetEChildren {
  return shift->get_echildren({dive => 'AuxCP', or_topological => 1, ignore_incorrect_tree_structure => 1, ordered => 1});
}

sub TGetEChildren {
  return shift->get_echildren({or_topological => 1, ignore_incorrect_tree_structure => 1, ordered => 1});
}

sub TGetEParents {
  return shift->get_eparents({or_topological => 1, ignore_incorrect_tree_structure => 1, ordered => 1});
}





package PMLTQ::Common::Effective::PML_A;

=item DiveAuxCP($node)

You can use this function as a C<through> argument to GetEParents and
GetEChildren. It skips all the prepositions and conjunctions when
looking for nodes which is what you usually want.

=cut

sub DiveAuxCP ($){
  $_[0]->{afun}=~/^Aux[CP]/ ? 1 : 0;
}#DiveAuxCP

=item GetEParents($node,$through)

Return linguistic parent of a given node as appears in an analytic
tree. The argument C<$through> should supply a function accepting one
node as an argument and returning true if the node should be skipped
on the way to parent or 0 otherwise. The most common C<DiveAuxCP> is
provided in this package.

=cut

sub _ExpandCoordGetEParents { # node through
  my ($node,$through)=@_;
  my @toCheck = $node->children;
  my @checked;
  while (@toCheck) {
    @toCheck=map {
      if (&$through($_)) { $_->children() }
      elsif($_->{afun}=~/Coord|Apos/&&$_->{is_member}){ _ExpandCoordGetEParents($_,$through) }
      elsif($_->{is_member}){ push @checked,$_;() }
      else{()}
    }@toCheck;
  }
  return @checked;
}# _ExpandCoordGetEParents

sub GetEParents { # node through
  my ($node,$through)=@_;
  my $init_node = $node; # only used for reporting errors
  return() if !$node or $node->{afun}=~/^(?:Coord|Apos|Aux[SCP])$/;
  if ($node->{is_member}) { # go to coordination head
    while ($node->{afun}!~/Coord|Apos|AuxS/ or $node->{is_member}) {
      $node=$node->parent;
      if (!$node) {
  print STDERR
    "GetEParents: Error - no coordination head $init_node->{AID}: ".ThisAddress($init_node)."\n";
        return();
      } elsif($node->{afun}eq'AuxS') {
  print STDERR
    "GetEParents: Error - no coordination head $node->{AID}: ".ThisAddress($node)."\n";
        return();
      }
    }
  }
  if (&$through($node->parent)) { # skip 'through' nodes
    while ($node and &$through($node->parent)) {
      $node=$node->parent;
    }
  }
  return unless $node;
  $node=$node->parent;
  return unless $node;
  return $node if $node->{afun}!~/Coord|Apos/;
  _ExpandCoordGetEParents($node,$through);
} # GetEParents






package PMLTQ::Common::Effective::PML_T;

=item ExpandCoord($node,$keep?)

If the given node is coordination or aposition (according to its TGTS
functor - attribute C<functor>) expand it to a list of coordinated
nodes. Otherwise return the node itself. If the argument C<keep> is
true, include the coordination/aposition node in the list as well.

=cut

sub ExpandCoord {
  my ($node,$keep)=@_;
  return unless $node;
  if (IsCoord($node)) {
    return (($keep ? $node : ()),
      map { ExpandCoord($_,$keep) }
      grep { $_->{is_member} } $node->children);
  } else {
    return ($node);
  }
} #ExpandCoord

=item IsCoord($node?)

Check if the given node is a coordination according to its TGTS
functor (attribute C<functor>)

=cut

sub IsCoord {
  my $node=$_[0];# || $this;
  return 0 unless $node;
  return 0 if $node->{nodetype} eq 'root'; # root does not have functor !!!
  return $node->{functor} =~ /ADVS|APPS|CONFR|CONJ|CONTRA|CSQ|DISJ|GRAD|OPER|REAS/;
}

=item GetEParents($node)

Return linguistic parents of a given node as appear in a TG tree.

=cut

sub GetEParents {
  my $node = $_[0];# || $this;
  return() if IsCoord($node);
  if ($node and $node->{is_member}) {
    while ($node and (!IsCoord($node) or $node->{is_member})) {
      $node=$node->parent;
    }
  }
  return () unless $node;
  $node=$node->parent;
  return () unless $node;
  return ($node) if !IsCoord($node);
  return (ExpandCoord($node));
} # GetEParents

