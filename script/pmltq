#!/usr/bin/env perl
# pmltq     pajas@ufal.mff.cuni.cz     2008/07/08 08:34:19

# ABSTRACT: Command line interface to PML-TQ

=head1 SYNOPSIS

  pmltq <command> [<args>]

or

  pmltq -P               for a list of configured connections
  pmltq -u               for usage
  pmltq -h <commandlist> for help
  pmltq --man            for the manual page
  pmltq --version        for version

  Available pmltq commands
    convert
    delete
    help
    initdb
    load
    man
    query
    verify
    version


=head1 DESCRIPTION

B<pmltq> is a command-line interface to PML-TQ. It can use either a
SQL-based query engine, btred, ntred, or jtred (btred over a SGE
cluster) to evaluate the query. The results are printed to the
standard output.

=head1 OPTIONS

=over 5

=item B<--print-servers|-P>

Print list of configured query server connections and exit. If a HTTP
service is specified using the --server option, the service is
contacted to provide a list of all other public PML-TQ services
running on the same server for which the user is authorized.

=item B<--usage|-u>

Print a brief help message on usage and exits.

=item B<--help|-h <commandlist>>

Prints the help page and exits.

=item B<--man>

Displays the help as manual page.

=item B<--version>

Print program version.

=back

=head1 COMMANDS

=head2 convert

  pmltq convert <treebank_config> <sql_dir>

Convert from PML to SQL

=head2 delete

  pmltq delete <treebank_config>

Delete the treebank from database.

=head2 help

=head2 initdb

  pmltq initdb <treebank_config>

Initialize empty database.

=head2 load

  pmltq load <treebank_config> <sql_dir>

Load treebank to database

=head2 man

=head2 query

  pmltq query [--server <URL_or_server_ID> ] [ <options> ] [ --stdin | --query-file <filename> | --query <query> | <query> ]
  pmltq query --btred [ <options> ] [ --stdin | --query-file <filename> | --query <query> ] [ -l <filelist> |  <file(s)> ]
  pmltq query --ntred [ <options> ] [ --stdin | --query-file <filename> | --query <query> ] [ -l <filelist> |  <file(s)> ]
  pmltq query --jtred [ <options> ] [ --stdin | --query-file <filename> | --query <query> ] [ -l <filelist> |  <file(s)> ]

or

  pmltq [options] [ --print-servers|-P | --node-types | --relations ]

=head3 options

=over 5

=item B<--sql|-S>

Use SQL-based query engine (default).

=item B<--btred|-B>

Query given files or filelist using btred.

=item B<--ntred|-N>

Query given files or filelist using ntred (ntred servers
must be already up and running).

=item B<--jtred|-J>

Run query query over given files/filelist using jtred (multiple btred
instances distributed over an SGE cluster).

=item B<--server|-s> URL_or_ID

If used with SQL-based engine, this option can be used to specify a
URL (http://hostname:port) to a pmltq http server, or an ID of a
pre-configured SQL or HTTP server (use B<--print-servers> to get a
list).

If used with btred or jtred, it can be used to specify a server to run
btred/jtred on using SSH.

If used with ntred, it can be used to specify a hostname and port
(hostname:port) for the ntred hub.

=item B<--stdin>

Read query from the standard input.

=item B<--query|-Q> string

Specify PML-TQ query on the command-line.

=item B<--query-file> filename

Read PML-TQ query from a given (utf-8 encoded text) file

=item B<--query-pml-file> filename

Read PML-TQ query from a given PML file

=item B<--query-id> ID

Use query with a given ID. If the input is a text file, it can contain more than one
query. In that case, each query must start with a line of the following form:

  # == query: ID ==

where ID is a unique identifier of the query. This option can be used
to select a single query from the input.

If the input is a PML file, then the ID is just the id of the query tree.

=item B<--filelist|-l> filename

This flag can be used with B<--btred>, B<--ntred>, or B<--jtred> to
spedify a file containing a list of files to search, each on a
separate line.

Note that for B<--ntred>, the files must be already loaded on the
B<ntred> servers and this flag simply allows you to specify a subcorpus.

=item B<--auth-id> URL_or_ID

Use username/password stored in the configuration for a given service
(spcified by URL or config-file ID) on the serice specified using --server.

=item B<--username> username

Username for a HTTP or SQL PML-TQ service.

=item B<--password> password

Password for a HTTP or SQL PML-TQ service.

=item B<--limit|-L> number

Only applicable to SQL-based engine.
Specify maximum number of results (i.e. rows printed by pmltq).

=item B<--timeout|-t> seconds

Only applicable to SQL-based engine.
Specify a timeout for the query. If the query evaluation takes longer
than a given number of B<seconds>, pmltq terminates the connection
with the server and returns with a message "Evaluation of query timed
out" and exit code 2. 

=item B<--config-file|-c> filename

Specify a configuration file. The configuration file is a XML file (in
fact, a PML instance conforming to the treebase_conf_schema.xml) that
lists available SQL engine configurations. If this option is not
provided, B<pmltq> attempts to find a file named treebase.conf in the
resource paths (namely in ~/.tred.d).

=item B<--node-types>

List available node types and exit.

=item B<--netgraph-query|-N> type_name

Assume the query is in NetGraph syntax and translate it to PMLTQ,
using a given node type as the default type.

=item B<--debug|-D>

Print some extended information (e.g. evaluation benchmarks).

=back

=head2 verify

  pmltq verify <treebank_config>

Check if database exists and that it contains some data

=head2 version

  pmltq version

Print program version.

=cut


use open IO => ':utf8';
use open ':std';

use warnings;
use strict;
$|=1;
use FindBin;

use lib ($FindBin::RealBin.'/../lib', ## PMLTQ
  );

use PMLTQ;
use PMLTQ::PML2BASE;
use PMLTQ::Commands;
use Treex::PML;
our $VERSION = $PMLTQ::VERSION;

use DBI;
use FindBin qw($RealBin);

use Getopt::Long;
use Pod::Usage;
use YAML::Tiny;
use File::Path qw( make_path );

Getopt::Long::Configure ("bundling");
my %error_msg = (invalid_param_n => "Invalid number of parameters !!! \n", connection => "Unable to connect to database !!!\n");
my %opts;


PMLTQ::Commands->run(@ARGV);




=x
if ($opts{usage}) {
  pod2usage(-msg => 'pmltq');
}
if ($opts{help} || $command eq 'help') {
  $opts{help} ||= [];
  my @command_list = grep {exists $commands{$_}} (@{$opts{help}}, @ARGV);
  pod2usage(-exitstatus => 0, @command_list ? (-sections => [map {"COMMANDS/$_"} @command_list], -verbose => 99) : (-verbose => 1) );
}
if ($opts{man} || $command eq 'man') {
  pod2usage(-exitstatus => 0, -verbose => 2);
}
if ($opts{version} || $command eq 'version') {
  print "$VERSION\n";
  exit;
}



if ($command eq 'convert') {
  pod2usage(-exitstatus => 1, -sections => ["COMMANDS/$command"], -verbose => 99, -msg => $error_msg{invalid_param_n}) unless @ARGV == 2;
  my $conf = load_config($ARGV[0]);
  cmd_convert(@ARGV);
  exit;
} elsif ($command eq 'delete') {
  pod2usage(-exitstatus => 1, -sections => ["COMMANDS/$command"], -verbose => 99, -msg => $error_msg{invalid_param_n}) unless @ARGV == 1;
  cmd_delete(@ARGV);
  exit;
} elsif ($command eq 'initdb') {
  pod2usage(-exitstatus => 1, -sections => ["COMMANDS/$command"], -verbose => 99, -msg => $error_msg{invalid_param_n}) unless @ARGV == 1;
  cmd_initdb(@ARGV);
  exit;
} elsif ($command eq 'load') {
  pod2usage(-exitstatus => 1, -sections => ["COMMANDS/$command"], -verbose => 99, -msg => $error_msg{invalid_param_n}) unless @ARGV == 2;
  cmd_load(@ARGV);
  exit;
} elsif ($command eq 'verify') {
  pod2usage(-exitstatus => 1, -sections => ["COMMANDS/$command"], -verbose => 99, -msg => $error_msg{invalid_param_n}) unless @ARGV == 1;
  cmd_verify(@ARGV);
  exit;
} 
=cut


package PMLTQ::Common::Effective;


sub mk_extra_tables {
  mk_eparent_table(@_) unless $opts{'no-eparents'};
  mk_a_rf_table(@_) unless $opts{'no-a-rf'};
}

sub mk_a_rf_table {
  my ($schema,$desc,$fh)=@_;
  my $name = $schema->get_root_name;
  my $table_name = PMLTQ::PML2BASE::rename_type($name);
  unless ($opts{'no-schema'}) {
    if ($name =~ /^tdata/) {
      $fh->{'#INIT_SQL'}->print(<<"EOF");
CREATE TABLE "${table_name}__#a_rf" ("#idx" INT, "#value" INT);
CREATE INDEX "#Ui_${table_name}_a_rf0" ON "${table_name}__#a_rf" ("#idx");
CREATE INDEX "#Ui_${table_name}_a_rf1" ON "${table_name}__#a_rf" ("#value");
INSERT INTO "#PML_USR_REL" VALUES('a/lex.rf|a/aux.rf',NULL,'t-node','a-node','${table_name}__#a_rf');
EOF

      $fh->{'#DELETE_SQL'}->print(<<"EOF");
DROP TABLE "${table_name}__#a_rf";
DELETE FROM "#PML_USR_REL" WHERE "tbl"='${table_name}__#a_rf';
EOF
      $fh->{'#POST_SQL'}->print(<<"EOF");
INSERT INTO "${table_name}__#a_rf"
  SELECT t."#idx" AS "#idx", a."lex" AS "#value"
    FROM "t-node" t JOIN "t-a" a ON a."#idx"=t."a"
  UNION
  SELECT t."#idx" AS "#idx", aux."#value" AS "#value"
    FROM "t-node" t JOIN "t-a" a ON a."#idx"=t."a" JOIN "t-a/aux.rf" aux ON aux."#idx"=a."aux.rf"
  UNION
  SELECT r."#idx" AS "#idx", r."atree" FROM "t-root" r;
EOF
    }
  }
}

sub mk_eparent_table {
    my ($schema,$desc,$fh)=@_;
    my $name = $schema->get_root_name;
    my @tables;
    my $table_name = PMLTQ::PML2BASE::rename_type($name.'__#eparents');

    if ($name eq 'treex_document') {
        ## init tables for both tdata and adata because
        ## treex_documents contains all trees in one document
        my $adata_c_table = PML2BASE::rename_type($name.'__adata#eparents_c');
        my $adata_table = PML2BASE::rename_type($name.'__adata#eparents');
        my $tdata_table = PML2BASE::rename_type($name.'__tdata#eparents');
        unless ($opts{'no-schema'}) {
            $fh->{'#INIT_SQL'}->print(<<"EOF");
INSERT INTO "#PML_USR_REL" VALUES('eparentC','echildC','a-node','a-node','${adata_c_table}');
INSERT INTO "#PML_USR_REL" VALUES('eparent','echild','a-node','a-node','${adata_table}');
INSERT INTO "#PML_USR_REL" VALUES('eparent','echild','t-node','t-node','${tdata_table}');
EOF
            $fh->{'#DELETE_SQL'}->print(<<"EOF");
DELETE FROM "#PML_USR_REL" WHERE "tbl"='${adata_table}';
DELETE FROM "#PML_USR_REL" WHERE "tbl"='${tdata_table}';
EOF
        }

        @tables = ($adata_table, $tdata_table, $adata_c_table);

    } else {
        @tables = ($table_name);

        unless ($opts{'no-schema'}) {
            my $node_type;
            if ($name =~ /^tdata/) {
                $node_type = 't-node';
            } elsif ($name =~ /^adata/) {
                $node_type = 'a-node';
            }

            if ($node_type) {
                my $node_table  = PMLTQ::PML2BASE::rename_type($node_type);
                $fh->{'#INIT_SQL'}->print(<<"EOF");
INSERT INTO "#PML_USR_REL" VALUES('eparent','echild','${node_type}','${node_type}','${table_name}');
EOF
                $fh->{'#DELETE_SQL'}->print(<<"EOF");
DELETE FROM "#PML_USR_REL" WHERE "tbl"='${table_name}';
EOF
            }
        }

    }

    for my $table (@tables) {
        $desc->{$table} = {
            table => $table,
            colspec => [
                ['#idx','INT'],
                ['#value','INT'],
            ],
            index => ["#idx","#value"]
        };
        open $fh->{$table},'>',PMLTQ::PML2BASE::get_full_path(PMLTQ::PML2BASE::to_filename($table));
    }
}

sub dump_eparent {
    my ($tree,$hash,$fh)=@_;
    my $name = $tree->type->get_schema->get_root_name;
    my $table_name = PMLTQ::PML2BASE::rename_type($name.'__#eparents');
    if ($name =~ /^adata/) {
        for my $node ($tree->descendants) {
            for my $p (PMLTQ::Common::Effective::PML_A::GetEParents($node,\&PMLTQ::Common::Effective::PML_A::DiveAuxCP)) {
                $fh->{$table_name}->print(PMLTQ::PML2BASE::mkdump($hash->{$node}{'#idx'},$hash->{$p}{'#idx'}));
            }
        }
    } elsif ($name =~ /^tdata/) {
        for my $node ($tree->descendants) {
            for my $p (PMLTQ::Common::Effective::PML_T::GetEParents($node)) {
                $fh->{$table_name}->print(PMLTQ::PML2BASE::mkdump($hash->{$node}{'#idx'},$hash->{$p}{'#idx'}));
            }
        }
    } elsif ($name eq 'treex_document' ) {
        my $adata_c_table = PMLTQ::PML2BASE::rename_type($name.'__adata#eparents_c');
        my $adata_table = PMLTQ::PML2BASE::rename_type($name.'__adata#eparents');
        my $tdata_table = PMLTQ::PML2BASE::rename_type($name.'__tdata#eparents');
        my $struct_name = $tree->type->get_structure_name||'';
        if ($struct_name eq 'a-root') {
            foreach my $anode ($tree->descendants) {
                foreach my $p (PMLTQ::Common::Effective::TreexUtils::AGetEParentsC($anode)) {
                    $fh->{$adata_c_table}->print(PMLTQ::PML2BASE::mkdump($hash->{$anode}{'#idx'}, $hash->{$p}{'#idx'}));
                }
                foreach my $p (PMLTQ::Common::Effective::TreexUtils::AGetEParents($anode)) {
                    $fh->{$adata_table}->print(PMLTQ::PML2BASE::mkdump($hash->{$anode}{'#idx'}, $hash->{$p}{'#idx'}));
                }
            }
        } elsif ($struct_name eq 't-root') {
            foreach my $tnode ($tree->descendants) {
                foreach my $p (PMLTQ::Common::Effective::TreexUtils::TGetEParents($tnode)) {
                    $fh->{$tdata_table}->print(PMLTQ::PML2BASE::mkdump($hash->{$tnode}{'#idx'}, $hash->{$p}{'#idx'}));
                }
            }
        }
    }
}

package PMLTQ::Common::Effective::TreexUtils;
sub AGetEParentsC {
  return shift->get_eparents({or_topological => 1, ignore_incorrect_tree_structure => 1, ordered => 1});
}

sub AGetEChildrenC {
  return shift->get_echildren({or_topological => 1, ignore_incorrect_tree_structure => 1, ordered => 1});
}

sub AGetEParents {
  return shift->get_eparents({dive => 'AuxCP', or_topological => 1, ignore_incorrect_tree_structure => 1, ordered => 1});
}

sub AGetEChildren {
  return shift->get_echildren({dive => 'AuxCP', or_topological => 1, ignore_incorrect_tree_structure => 1, ordered => 1});
}

sub TGetEChildren {
  return shift->get_echildren({or_topological => 1, ignore_incorrect_tree_structure => 1, ordered => 1});
}

sub TGetEParents {
  return shift->get_eparents({or_topological => 1, ignore_incorrect_tree_structure => 1, ordered => 1});
}





package PMLTQ::Common::Effective::PML_A;

=item DiveAuxCP($node)

You can use this function as a C<through> argument to GetEParents and
GetEChildren. It skips all the prepositions and conjunctions when
looking for nodes which is what you usually want.

=cut

sub DiveAuxCP ($){
  $_[0]->{afun}=~/^Aux[CP]/ ? 1 : 0;
}#DiveAuxCP

=item GetEParents($node,$through)

Return linguistic parent of a given node as appears in an analytic
tree. The argument C<$through> should supply a function accepting one
node as an argument and returning true if the node should be skipped
on the way to parent or 0 otherwise. The most common C<DiveAuxCP> is
provided in this package.

=cut

sub _ExpandCoordGetEParents { # node through
  my ($node,$through)=@_;
  my @toCheck = $node->children;
  my @checked;
  while (@toCheck) {
    @toCheck=map {
      if (&$through($_)) { $_->children() }
      elsif($_->{afun}=~/Coord|Apos/&&$_->{is_member}){ _ExpandCoordGetEParents($_,$through) }
      elsif($_->{is_member}){ push @checked,$_;() }
      else{()}
    }@toCheck;
  }
  return @checked;
}# _ExpandCoordGetEParents

sub GetEParents { # node through
  my ($node,$through)=@_;
  my $init_node = $node; # only used for reporting errors
  return() if !$node or $node->{afun}=~/^(?:Coord|Apos|Aux[SCP])$/;
  if ($node->{is_member}) { # go to coordination head
    while ($node->{afun}!~/Coord|Apos|AuxS/ or $node->{is_member}) {
      $node=$node->parent;
      if (!$node) {
  print STDERR
    "GetEParents: Error - no coordination head $init_node->{AID}: ".ThisAddress($init_node)."\n";
        return();
      } elsif($node->{afun}eq'AuxS') {
  print STDERR
    "GetEParents: Error - no coordination head $node->{AID}: ".ThisAddress($node)."\n";
        return();
      }
    }
  }
  if (&$through($node->parent)) { # skip 'through' nodes
    while ($node and &$through($node->parent)) {
      $node=$node->parent;
    }
  }
  return unless $node;
  $node=$node->parent;
  return unless $node;
  return $node if $node->{afun}!~/Coord|Apos/;
  _ExpandCoordGetEParents($node,$through);
} # GetEParents






package PMLTQ::Common::Effective::PML_T;

=item ExpandCoord($node,$keep?)

If the given node is coordination or aposition (according to its TGTS
functor - attribute C<functor>) expand it to a list of coordinated
nodes. Otherwise return the node itself. If the argument C<keep> is
true, include the coordination/aposition node in the list as well.

=cut

sub ExpandCoord {
  my ($node,$keep)=@_;
  return unless $node;
  if (IsCoord($node)) {
    return (($keep ? $node : ()),
      map { ExpandCoord($_,$keep) }
      grep { $_->{is_member} } $node->children);
  } else {
    return ($node);
  }
} #ExpandCoord

=item IsCoord($node?)

Check if the given node is a coordination according to its TGTS
functor (attribute C<functor>)

=cut

sub IsCoord {
  my $node=$_[0];# || $this;
  return 0 unless $node;
  return 0 if $node->{nodetype} eq 'root'; # root does not have functor !!!
  return $node->{functor} =~ /ADVS|APPS|CONFR|CONJ|CONTRA|CSQ|DISJ|GRAD|OPER|REAS/;
}

=item GetEParents($node)

Return linguistic parents of a given node as appear in a TG tree.

=cut

sub GetEParents {
  my $node = $_[0];# || $this;
  return() if IsCoord($node);
  if ($node and $node->{is_member}) {
    while ($node and (!IsCoord($node) or $node->{is_member})) {
      $node=$node->parent;
    }
  }
  return () unless $node;
  $node=$node->parent;
  return () unless $node;
  return ($node) if !IsCoord($node);
  return (ExpandCoord($node));
} # GetEParents

